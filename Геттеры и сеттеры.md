
---
## Задание: 
Для написанной ранее иерархии классов необходимо написать геттеры и сеттер

---

Конечно! Если не использовать декораторы `@property`, геттеры и сеттеры можно реализовать как обычные методы класса. Такой подход ближе к классической реализации инкапсуляции в языках вроде Java, но в Python он используется реже из-за удобства свойств (`property`). Однако понимание этого метода полезно для работы с legacy-кодом или в случаях, где требуется явный контроль.

---

### Реализация геттеров и сеттеров через методы

#### Пример класса `Person` с методами `get_age()` и `set_age()`:
```python
class Person:
    def __init__(self, age):
        self._age = age  # Условно "приватный" атрибут (по соглашению)

    # Геттер
    def get_age(self):
        print("Получаем возраст")
        return self._age

    # Сеттер
    def set_age(self, value):
        if value < 0:
            raise ValueError("Возраст не может быть отрицательным")
        print("Устанавливаем возраст")
        self._age = value

# Использование
p = Person(25)
print(p.get_age())  # 25
p.set_age(30)       # Корректное изменение
p.set_age(-5)       # Вызовет исключение: ValueError
```

---

### Особенности подхода
1. **Явный вызов методов**:  
   Пользователь класса должен явно вызывать `get_age()` и `set_age()`, что усложняет синтаксис:
   ```python
   # С property:
   p.age = 30

   # С методами:
   p.set_age(30)
   ```

2. **Приватность атрибута**:  
   Атрибут `_age` помечен как "приватный" (по соглашению через `_`), но технически доступен извне:
   ```python
   print(p._age)  # Работает, но так делать не рекомендуется!
   ```

3. **Гибкость**:  
   Можно добавлять множество методов для разных атрибутов (например, `get_name()`, `set_name()`).

---

### Плюсы и минусы

| **Плюсы**                          | **Минусы**                          |
|------------------------------------|-------------------------------------|
| Подходит для сложной логики (например, сеттер с множеством параметров). | Менее удобный синтаксис. |
| Понятно для разработчиков из мира Java/C++. | Нарушает принцип "единственной ответственности" (класс управляет данными и логикой). |
| Позволяет использовать аннотации типов или валидацию в методах. | Нет защиты от прямого доступа к `_age` (только соглашение). |

---

### Сравнение с `@property`

#### 1. Пример с `@property`:
```python
p.age = 30  # Как обращение к атрибуту
```

#### 2. Пример с методами:
```python
p.set_age(30)  # Явный вызов метода
```

**Итог**:  
`@property` делает код чище, но методы дают больше гибкости в сложных сценариях.

---

### Когда использовать методы вместо `@property`?
1. **Для обратной совместимости**: Если в коде уже используются методы `get_x()`/`set_x()`.
2. **Сложные операции**: Например, если сеттер принимает несколько аргументов:
   ```python
   def set_coordinates(self, x, y):
       self._x = x
       self._y = y
   ```
3. **Динамическое имя атрибута**: Если имя свойства определяется на лету (например, через строки).

---

### Пример расширенного сценария
```python
class Rectangle:
    def __init__(self, width, height):
        self._width = width
        self._height = height

    # Геттеры
    def get_width(self):
        return self._width

    def get_height(self):
        return self._height

    # Сеттеры с валидацией
    def set_width(self, value):
        if value <= 0:
            raise ValueError("Ширина должна быть положительной")
        self._width = value

    def set_height(self, value):
        if value <= 0:
            raise ValueError("Высота должна быть положительной")
        self._height = value

# Использование
rect = Rectangle(10, 20)
rect.set_width(15)
print(rect.get_width())  # 15
```

---

### Итог
Геттеры и сеттеры без `@property` — это «классический» подход, который:
- Требует явного вызова методов (`get()`/`set()`),
- Менее элегантен, но более гибок,
- Полезен в специфических сценариях, где `@property` неудобен.

**Рекомендация**: В новых проектах используйте `@property`, а методы `get_x()`/`set_x()` применяйте только при необходимости.
